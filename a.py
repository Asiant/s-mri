# Autogenerated with SMOP version 
# C:\Users\Rohan Kumar\Anaconda\Scripts\smop-script.py chenvese.m

from __future__ import division
try:
    from runtime import *
except ImportError:
    from smop.runtime import *

def chenvese_(I=None,mask=None,num_iter=None,mu=None,method=None,*args,**kwargs):
    varargin = cellarray(args)
    nargin = 5-[I,mask,num_iter,mu,method].count(None)+len(args)

    if (not exist_(char('mu'),char('var'))):
        mu=0.2
    if (not exist_(char('method'),char('var'))):
        method=char('chan')
    s=200.0 / min_(size_(I,1),size_(I,2))
    if s < 1:
        I=imresize_(I,s)
    if ischar_(mask):
        if char('small') == lower_____(mask):
            mask=maskcircle2_(I,char('small'))
        else:
            if char('medium') == lower_____(mask):
                mask=maskcircle2_(I,char('medium'))
            else:
                if char('large') == lower_____(mask):
                    mask=maskcircle2_(I,char('large'))
                else:
                    if char('whole') == lower_____(mask):
                        mask=maskcircle2_(I,char('whole'))
                    else:
                        if char('whole+small') == lower_____(mask):
                            m1=maskcircle2_(I,char('whole'))
                            m2=maskcircle2_(I,char('small'))
                            mask=zeros_(size_(I,1),size_(I,2),2)
                            mask[:,:,1]=m1[:,:,1]
                            mask[:,:,2]=m2[:,:,2]
                        else:
                            error_(char('unrecognized mask shape name (MASK).'))
    else:
        if s < 1:
            mask=imresize_(mask,s)
        if size_(mask,1) > size_(I,1) or size_(mask,2) > size_(I,2):
            error_(char('dimensions of mask unmathch those of the image.'))
        if char('multiphase') == lower_(method):
            if (size_(mask,3) == 1):
                error_(char('multiphase requires two masks but only gets one.'))
    if char('chan') == lower___(method):
        if size_(I,3) == 3:
            P=rgb2gray_(uint8_(I))
            P=double_(P)
        else:
            if size_(I,3) == 2:
                P=0.5.dot((double_(I[:,:,1]) + double_(I[:,:,2])))
            else:
                P=double_(I)
        layer=1
    else:
        if char('vector') == lower___(method):
            s=200.0 / min_(size_(I,1),size_(I,2))
            I=imresize_(I,s)
            mask=imresize_(mask,s)
            layer=size_(I,3)
            if layer == 1:
                display_(char('only one image component for vector image'))
            P=double_(I)
        else:
            if char('multiphase') == lower___(method):
                layer=size_(I,3)
                if size_(I,1) * size_(I,2) > 200 ** 2:
                    s=200.0 / min_(size_(I,1),size_(I,2))
                    I=imresize_(I,s)
                    mask=imresize_(mask,s)
                P=double_(I)
            else:
                error_(char('!invalid method'))
    if [char('chan'),char('vector')] == lower__(method):
        mask=mask[:,:,1]
        phi0=bwdist_(mask) - bwdist_(1 - mask) + im2double_(mask) - 0.5
        force=copy_(eps)
        figure_()
        subplot_(2,2,1)
        imshow_(I)
        title_(char('Input Image'))
        subplot_(2,2,2)
        contour_(flipud_(phi0),[0,0],char('r'),char('LineWidth'),1)
        title_(char('initial contour'))
        subplot_(2,2,3)
        title_(char('Segmentation'))
        for n in arange_(1,num_iter).reshape(-1):
            inidx=find_(phi0 >= 0)
            outidx=find_(phi0 < 0)
            force_image=0
            for i in arange_(1,layer).reshape(-1):
                L=im2double_(P[:,:,i])
                c1=sum_(sum_(L.dot(Heaviside_(phi0)))) / (length_(inidx) + eps)
                c2=sum_(sum_(L.dot((1 - Heaviside_(phi0))))) / (length_(outidx) + eps)
                force_image=- (L - c1) ** 2 + (L - c2) ** 2 + force_image
            force=mu * kappa_(phi0) / max_(max_(abs_(kappa_(phi0)))) + 1 / layer.dot(force_image)
            force=force / (max_(max_(abs_(force))))
            dt=0.5
            old=copy_(phi0)
            phi0=phi0 + dt.dot(force)
            new=copy_(phi0)
            indicator=checkstop_(old,new,dt)
            if (mod_(n,20) == 0):
                showphi_(I,phi0,n)
            if indicator:
                showphi_(I,phi0,n)
                seg=phi0 <= 0
                subplot_(2,2,4)
                imshow_(seg)
                title_(char('Global Region-Based Segmentation'))
                return seg
        showphi_(I,phi0,n)
        seg=phi0 <= 0
        subplot_(2,2,4)
        imshow_(seg)
        title_(char('Global Region-Based Segmentation'))
    else:
        if char('multiphase') == lower__(method):
            mask1=mask[:,:,1]
            mask2=mask[:,:,2]
            phi1=bwdist_(mask1) - bwdist_(1 - mask1) + im2double_(mask1) - 0.5
            phi2=bwdist_(mask2) - bwdist_(1 - mask2) + im2double_(mask2) - 0.5
            figure_()
            subplot_(2,2,1)
            if layer != 1:
                imshow_(I)
                title_(char('Input Image'))
            else:
                imagesc_(P)
                axis_(char('image'))
                colormap_(gray)
                title_(char('Input Image'))
            subplot_(2,2,2)
            hold_(char('on'))
            contour_(flipud_(mask1),[0,0],char('r'),char('LineWidth'),2.5)
            contour_(flipud_(mask1),[0,0],char('x'),char('LineWidth'),1)
            contour_(flipud_(mask2),[0,0],char('g'),char('LineWidth'),2.5)
            contour_(flipud_(mask2),[0,0],char('x'),char('LineWidth'),1)
            title_(char('initial contour'))
            hold_(char('off'))
            subplot_(2,2,3)
            title_(char('Segmentation'))
            for n in arange_(1,num_iter).reshape(-1):
                nb1=find_(phi1 < 1.2 and phi1 >= - 1.2)
                inidx1=find_(phi1 >= 0)
                outidx1=find_(phi1 < 0)
                nb2=find_(phi2 < 1.2 and phi2 >= - 1.2)
                inidx2=find_(phi2 >= 0)
                outidx2=find_(phi2 < 0)
                cc11=intersect_(inidx1,inidx2)
                cc12=intersect_(inidx1,outidx2)
                cc21=intersect_(outidx1,inidx2)
                cc22=intersect_(outidx1,outidx2)
                f_image11=0
                f_image12=0
                f_image21=0
                f_image22=0
                for i in arange_(1,layer).reshape(-1):
                    L=im2double_(P[:,:,i])
                    if isempty_(cc11):
                        c11=copy_(eps)
                    else:
                        c11=mean_(L[cc11])
                    if isempty_(cc12):
                        c12=copy_(eps)
                    else:
                        c12=mean_(L[cc12])
                    if isempty_(cc21):
                        c21=copy_(eps)
                    else:
                        c21=mean_(L[cc21])
                    if isempty_(cc22):
                        c22=copy_(eps)
                    else:
                        c22=mean_(L[cc22])
                    f_image11=(L - c11) ** 2.0 * Heaviside_(phi1).dot(Heaviside_(phi2)) + f_image11
                    f_image12=(L - c12) ** 2.0 * Heaviside_(phi1).dot((1 - Heaviside_(phi2))) + f_image12
                    f_image21=(L - c21) ** 2.0 * (1 - Heaviside_(phi1)).dot(Heaviside_(phi2)) + f_image21
                    f_image22=(L - c22) ** 2.0 * (1 - Heaviside_(phi1)).dot((1 - Heaviside_(phi2))) + f_image22
                curvature1=mu * kappa_(phi1)
                curvature1=curvature1[nb1]
                fim1=1 / layer.dot((- f_image11[nb1] + f_image21[nb1] - f_image12[nb1] + f_image22[nb1]))
                fim1=fim1 / max_(abs_(fim1) + eps)
                curvature2=mu * kappa_(phi2)
                curvature2=curvature2[nb2]
                fim2=1 / layer.dot((- f_image11[nb2] + f_image12[nb2] - f_image21[nb2] + f_image22[nb2]))
                fim2=fim2 / max_(abs_(fim2) + eps)
                force1=curvature1 + fim1
                force2=curvature2 + fim2
                dt=1.5
                old[:,:,1]=phi1
                old[:,:,2]=phi2
                phi1[nb1]=phi1[nb1] + dt.dot(force1)
                phi2[nb2]=phi2[nb2] + dt.dot(force2)
                new[:,:,1]=phi1
                new[:,:,2]=phi2
                indicator=checkstop_(old,new,dt)
                if indicator:
                    showphi_(I,new,n)
                    seg11=(phi1 > 0 and phi2 > 0)
                    seg12=(phi1 > 0 and phi2 < 0)
                    seg21=(phi1 < 0 and phi2 > 0)
                    seg22=(phi1 < 0 and phi2 < 0)
                    se=strel_(char('disk'),1)
                    aa1=imerode_(seg11,se)
                    aa2=imerode_(seg12,se)
                    aa3=imerode_(seg21,se)
                    aa4=imerode_(seg22,se)
                    seg=aa1 + 2 * aa2 + 3 * aa3 + 4 * aa4
                    subplot_(2,2,4)
                    imagesc_(seg)
                    axis_(char('image'))
                    title_(char('Global Region-Based Segmentation'))
                    return seg
                phi1=reinitialization_(phi1,0.6)
                phi2=reinitialization_(phi2,0.6)
                if (mod_(n,20) == 0):
                    phi[:,:,1]=phi1
                    phi[:,:,2]=phi2
                    showphi_(I,phi,n)
            phi[:,:,1]=phi1
            phi[:,:,2]=phi2
            showphi_(I,phi,n)
            seg11=(phi1 > 0 and phi2 > 0)
            seg12=(phi1 > 0 and phi2 < 0)
            seg21=(phi1 < 0 and phi2 > 0)
            seg22=(phi1 < 0 and phi2 < 0)
            se=strel_(char('disk'),1)
            aa1=imerode_(seg11,se)
            aa2=imerode_(seg12,se)
            aa3=imerode_(seg21,se)
            aa4=imerode_(seg22,se)
            seg=aa1 + 2 * aa2 + 3 * aa3 + 4 * aa4
            subplot_(2,2,4)
            imagesc_(seg)
            axis_(char('image'))
            title_(char('Global Region-Based Segmentation'))
    return seg
